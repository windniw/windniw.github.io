<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>中位数在线算法</title>
    <link href="/2020/12/30/median/"/>
    <url>/2020/12/30/median/</url>
    
    <content type="html"><![CDATA[<p>动态返回输入序列的中位数。</p><a id="more"></a><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>中位数的离线算法没有任何难度，排序取中位元素即可，但在线算法并没有这么直观。显然，这个问题在不卡输入数据的情况下，不可能通过动态规划等思路压缩状态来降低时间的消耗，则需要在插入时维护已有数据集，来加速查找中位数的操作。那么对一个在线的算法需要考虑的操作需包括：</p><ul><li>查找插入位置</li><li>插入</li><li>查找中位数</li></ul><p>可以简单考虑下几种常用数据结构能否直接满足此诉求</p><ul><li>链表</li></ul><p>寻找插入点 $O(n)$，插入 $O(1)$，查找中位点 $O(n)$。</p><p>一种可能的优化点：由于每次仅插入一个元素，取 p 常驻于中点，根据插入点在 p 的左右，相应移动 p 维护其中点位置，可以将查找优化到 $O(1)$。</p><ul><li>数组</li></ul><p>寻找插入点 $O(log_2(n))$，插入 $O(n)$，查找中位点 $O(1)$。</p><ul><li>堆</li></ul><p>寻找插入点 $O(log_2(n))$，插入 $O(log_2(n))$，查找中位点 $O(log_2(n)*n)$ (先 pop 一半再 push 回去)。</p><ul><li>排序树</li></ul><p>寻找插入点 $O(log_2(n))$，插入 $O(1)$，查找中位点 $O(n)$。</p><p>一种可能的优化点：对每个节点维护其子节点个数，在树的旋转时维护该值，可以将查找优化到 $O(log_2(n))$</p><p>另一种可能的优化点：类似上面提到的链表优化，先取 p 常驻于中点，根据插入点维护 p 的中点位置，可以将查找优化到 $O(1)$</p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>显然，上面几个思路中，只有通过排序树的搞法是最优的。但在实际实现中，依赖具体语言的容器类是否支持此类操作，否则还需要自行实现一棵排序树。一般而言，会使用另外一种更通用便于实现的方法。</p><p><strong>大顶堆 + 小顶堆</strong></p><p>每次插入元素时，维护两个容量相差不大于 1 的大顶堆和小顶堆，且满足对于小顶堆中每个元素，均大于或等于大顶堆的每个元素。执行以下算法：</p><pre><code class="hljs python">add k:  <span class="hljs-comment"># 新元素 k 与两堆顶元素比较，加入满足要求的一个堆</span>  <span class="hljs-keyword">if</span> k &gt; max_heap.top:      max_heap.push(k)  <span class="hljs-keyword">else</span>:      min_heap.push(k)  <span class="hljs-comment"># 调整两个堆的大小直至相差在 1 以内</span>  <span class="hljs-keyword">while</span> max_heap.len + <span class="hljs-number">1</span> &lt; min_heap.len:      max_heap.push(min_heap.pop)   <span class="hljs-keyword">while</span> min_heap.len + <span class="hljs-number">1</span> &lt; max_heap.len:      min_heap.push(max_heap.pop)</code></pre><p>注意在每次添加完元素后，都需要调整两个堆的元素。且由于之前插入时已经调整过一次，那么每次至多两个堆各调整一次即可重新平衡，插入元素时间复杂度为 $O(log_2n)$。</p><p>而对于查找中位数，显然有中位数必然为两堆顶之一，或两堆顶的平均数，时间复杂度 $O(1)$。</p><p>在此，我们通过两道题目来解决这个问题。</p><h2 id="数据流的中位数"><a href="#数据流的中位数" class="headerlink" title="数据流的中位数"></a>数据流的中位数</h2><blockquote><p><a href="https://leetcode-cn.com/problems/find-median-from-data-stream" target="_blank" rel="noopener">295. 数据流的中位数</a></p><p>初始数组为空，持续向数组添加元素，并随时返回其中位数。</p></blockquote><p>标准题目，思路如上所述，以 <code>add 5, 10, 20, 30</code> 为例，流程见下图</p><p><img src="/img/median_0.png" alt="295_flow"></p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Heap</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>        self.data = []        self.k = <span class="hljs-number">1</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">max_heap</span><span class="hljs-params">(self)</span>:</span>        self.k = <span class="hljs-number">-1</span>        <span class="hljs-keyword">return</span> self    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">top</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-keyword">return</span> self.data[<span class="hljs-number">0</span>] * self.k    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-keyword">return</span> self.k * heapq.heappop(self.data)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push</span><span class="hljs-params">(self, item)</span>:</span>        <span class="hljs-keyword">return</span> heapq.heappush(self.data, item * self.k)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">len</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-keyword">return</span> len(self.data)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">empty</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-keyword">return</span> len(self.data) == <span class="hljs-number">0</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MedianFinder</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>        self.min_part = Heap().max_heap()        self.max_part = Heap()    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addNum</span><span class="hljs-params">(self, num: int)</span> -&gt; <span class="hljs-keyword">None</span>:</span>        m1, m2 = self.min_part, self.max_part        m1.push(num) <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> m1.empty() <span class="hljs-keyword">and</span> num &lt; m2.top() <span class="hljs-keyword">else</span> m2.push(num)        <span class="hljs-keyword">while</span> m2.len() &gt; m1.len() + <span class="hljs-number">1</span>:            m1.push(m2.pop())        <span class="hljs-keyword">while</span> m1.len() &gt; m2.len() + <span class="hljs-number">1</span>:            m2.push(m1.pop())    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findMedian</span><span class="hljs-params">(self)</span> -&gt; float:</span>        l1, l2 = self.min_part.len(), self.max_part.len()        <span class="hljs-keyword">if</span> l1 &gt; l2:            <span class="hljs-keyword">return</span> self.min_part.top()        <span class="hljs-keyword">elif</span> l1 &lt; l2:            <span class="hljs-keyword">return</span> self.max_part.top()        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">return</span> (self.min_part.top() + self.max_part.top()) / <span class="hljs-number">2</span></code></pre><h2 id="滑动窗口中位数"><a href="#滑动窗口中位数" class="headerlink" title="滑动窗口中位数"></a>滑动窗口中位数</h2><blockquote><p><a href="https://leetcode-cn.com/problems/sliding-window-median" target="_blank" rel="noopener">480. 滑动窗口中位数</a></p><p>给定数组 nums 与窗口大小 k，求数组从左向右每个窗口的中位数</p></blockquote><p>大的思路不变，还是维护双堆。与 <strong>295</strong> 相比，多了一个窗口限制，即不能只考虑向两个堆中加元素，还得考虑移除的情况。然而，从堆中挪走一个特定元素时间复杂度为 $O(nlog_2n)$。若每次窗口滑动时，都去即时移除堆中元素，复杂度会直接退化到维护一个堆的做法。考虑到在本题的要求下，即时移除元素是不必要的操作，因为要求的是中位数，若同时向两个堆中塞入不等于堆顶的元素，中位数不改变。也就是说，不在堆顶的元素实际上不影响我们对中位数的求解，可以做延迟删除。</p><p>引入<code>balance</code> 变量来记录<strong>实际</strong>上大顶堆比小顶堆多的元素数量，每次用 <code>multiset</code> 来记录移除元素。思路类似，每次调整到 <code>0 &lt;= balance &lt;= 1</code>，调整策略为若堆顶元素为已删除元素，直接抛出，否则在两堆间迁移直至平衡。 </p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Heap</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>        self.data = []        self.k = <span class="hljs-number">1</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">max_heap</span><span class="hljs-params">(self)</span>:</span>        self.k = <span class="hljs-number">-1</span>        <span class="hljs-keyword">return</span> self    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">top</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-keyword">return</span> self.data[<span class="hljs-number">0</span>] * self.k    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-keyword">return</span> self.k * heapq.heappop(self.data)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push</span><span class="hljs-params">(self, item)</span>:</span>        <span class="hljs-keyword">return</span> heapq.heappush(self.data, item * self.k)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">len</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-keyword">return</span> len(self.data)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">empty</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-keyword">return</span> len(self.data) == <span class="hljs-number">0</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MultiSet</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>        self.data = &#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(self, x)</span>:</span>        <span class="hljs-keyword">if</span> x <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.data:            self.data[x] = <span class="hljs-number">0</span>        self.data[x] += <span class="hljs-number">1</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">remove</span><span class="hljs-params">(self, x)</span>:</span>        self.data[x] -= <span class="hljs-number">1</span>        <span class="hljs-keyword">if</span> self.data[x] == <span class="hljs-number">0</span>:            <span class="hljs-keyword">del</span> (self.data[x])    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">contains</span><span class="hljs-params">(self, x)</span> -&gt; bool:</span>        <span class="hljs-keyword">return</span> x <span class="hljs-keyword">in</span> self.data<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">medianSlidingWindow</span><span class="hljs-params">(self, nums: List[int], k: int)</span> -&gt; List[float]:</span>        res, m1, m2, cache, balance = [], Heap().max_heap(), Heap(), MultiSet(), <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> enumerate(nums):            <span class="hljs-keyword">if</span> m1.empty() <span class="hljs-keyword">or</span> x &lt;= m1.top():                m1.push(x)                balance += <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                m2.push(x)                balance -= <span class="hljs-number">1</span>            <span class="hljs-keyword">if</span> i &gt;= k:                cache.add(nums[i - k])                balance += <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> nums[i - k] &lt;= m1.top() <span class="hljs-keyword">else</span> <span class="hljs-number">1</span>            <span class="hljs-keyword">while</span> balance != <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> balance != <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> m1.empty() <span class="hljs-keyword">and</span> cache.contains(                    m1.top()) <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> m2.empty() <span class="hljs-keyword">and</span> cache.contains(                    m2.top()):                <span class="hljs-keyword">if</span> balance &gt; <span class="hljs-number">1</span>:                    m2.push(m1.pop())                    balance -= <span class="hljs-number">2</span>                <span class="hljs-keyword">if</span> balance &lt; <span class="hljs-number">0</span>:                    m1.push(m2.pop())                    balance += <span class="hljs-number">2</span>                <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> m1.empty() <span class="hljs-keyword">and</span> cache.contains(m1.top()):                    cache.remove(m1.pop())                <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> m2.empty() <span class="hljs-keyword">and</span> cache.contains(m2.top()):                    cache.remove(m2.pop())            <span class="hljs-keyword">if</span> i &gt;= k - <span class="hljs-number">1</span>:                <span class="hljs-keyword">if</span> balance == <span class="hljs-number">0</span>:                    res.append((m1.top() + m2.top()) / <span class="hljs-number">2</span>)                <span class="hljs-keyword">else</span>:                    res.append(m1.top() <span class="hljs-keyword">if</span> balance == <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> m2.top())        <span class="hljs-keyword">return</span> res</code></pre>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最大矩阵和问题</title>
    <link href="/2020/11/20/max_matrix_sum/"/>
    <url>/2020/11/20/max_matrix_sum/</url>
    
    <content type="html"><![CDATA[<p>子矩阵的最大和。</p><a id="more"></a><blockquote><p><a href="https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/" target="_blank" rel="noopener">363. 矩形区域不超过 K 的最大数值和</a></p><p>给矩阵 matrix，求其子矩阵和最大且小于 k 的值</p></blockquote><p>简单说，二维数组有很大一类思路是压缩成一维数组求解，本题就是这样。在聊这题怎么写之前，先来看两道简化版的题目。</p><h2 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h2><blockquote><p><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">53. 最大子序和</a></p><p>给数组 nums，求其连续子序列中，最大的和</p></blockquote><p>思路：DP。令 dp[i] 记录以 nums[i] 为最后子序列最后一个元素的最大和。有如下状态转移公式，若当前最大连续子序列和小于 0，则直接放弃所有前缀数字，从 0 开始。</p><p>$$<br>dp[i] =<br>\begin{cases}<br>\max(nums[0], 0), &amp; \text{n = 0}  \<br>\max(dp[i-1] + nums[i], 0), &amp; \text{n $\neq$ 0}<br>\end{cases}<br>$$</p><p><strong>时间复杂度 $O(n)$, 压缩状态后空间 $O(1)$。这个解法也称为 kadane 算法。</strong></p><p>若要求子序列长度不能为 0 ，简单修改状态方程即可</p><p>$$<br>dp[i] =<br>\begin{cases}<br>nums[0], &amp; \text{n = 0}  \<br>\max(dp[i-1] + nums[i], nums[i]), &amp; \text{n $\neq$ 0}<br>\end{cases}<br>$$</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">max_subarray</span><span class="hljs-params">(A)</span>:</span>    max_ending_here = max_so_far = A[<span class="hljs-number">0</span>]    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,lengh(A)):        max_ending_here = max(max_ending_here, max_ending_here + A[i])        max_so_far = max(max_so_far, max_ending_here)    <span class="hljs-keyword">return</span> max_so_far</code></pre><h2 id="最大子序和-1"><a href="#最大子序和-1" class="headerlink" title="最大子序和 +"></a>最大子序和 +</h2><p>接下来在上题补充一个条件</p><blockquote><p>给数组 nums, 求其连续子序列中，<strong>最大且不超过 k</strong> 的和</p></blockquote><p>虽然只增加了一个条件，但不能再沿用之前的 DP 做法。这里依然是无后效性的，但只记录以 nums[i] 为最末元素的最大和或不超过k的最大和，并不足以推出 nums[i:1] 的状态。所以，增加这个约束后，需要换一种思路。</p><p>思路：记最优解为 $res = sum(nums[i:j+1])$，有 </p><p>$$res = sum(nums[i:j+1]) $$</p><p>$$res = sum(nums[0:j+1]) - sum(nums[0:i])$$</p><p>用 arr 来记录扫描过程中的前缀和, cur 记录扫描过程的当前前缀和，维护 arr 有序检索尽量满足 cur - p &lt;= k 的前缀和 p。arr 需要支持动态插入与二分查询，用平衡树可以得到最优的性能。</p><p><strong>时间复杂度 $O(nlog_n)$ ，空间复杂度 $O(n)$</strong></p><pre><code class="hljs python"><span class="hljs-comment"># 这里用 bisect 只是因为 python 没有现成的平衡树，bisect.insort_left 并没有达到 log_n 的插入能力</span><span class="hljs-comment"># arr 初始化为 [0] 而不是 []，预处理子序列不为空的逻辑</span>cur, arr = <span class="hljs-number">0</span>, [<span class="hljs-number">0</span>]<span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> nums:    cur += s    p = bisect.bisect_left(arr, cur - k)    <span class="hljs-keyword">if</span> p &lt; len(arr):        res = max(res, cur - arr[p])    bisect.insort_left(arr, cur)</code></pre><h2 id="最大矩阵和"><a href="#最大矩阵和" class="headerlink" title="最大矩阵和"></a>最大矩阵和</h2><p>解决完一维的问题，可以回头看二维的问题了</p><blockquote><p>给矩阵 matrix，求其子矩阵和最大且小于 k 的值</p></blockquote><p>思路：在本题中，题目声明了行高远大于列宽。所以我们枚举列，压缩行，将二维问题转换为一维问题。</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxSumSubmatrix</span><span class="hljs-params">(self, matrix: List[List[int]], k: int)</span> -&gt; int:</span>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> matrix <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> matrix[<span class="hljs-number">0</span>]:        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    n, m = len(matrix), len(matrix[<span class="hljs-number">0</span>])    res = float(<span class="hljs-string">"-inf"</span>)    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(m):        sum_list = [<span class="hljs-number">0</span>] * n        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(i, m):            <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> range(n):                sum_list[l] += matrix[l][j]            t, visit = <span class="hljs-number">0</span>, [<span class="hljs-number">0</span>]            <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> sum_list:                t += s                p = bisect.bisect_left(visit, t - k)                <span class="hljs-keyword">if</span> p &lt; len(visit):                    res = max(res, t - visit[p])                bisect.insort_left(visit, t)    <span class="hljs-keyword">return</span> res</code></pre><p><strong>时间复杂度 $O(m^2nlog_n)$，时间复杂度 $O(n)$</strong></p>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes Admission Controllers</title>
    <link href="/2019/07/15/kubernetes_admission_controllers/"/>
    <url>/2019/07/15/kubernetes_admission_controllers/</url>
    
    <content type="html"><![CDATA[<p><strong>Kubernetes Admission Controllers</strong> 提供了一个资源创建，修改流程的切面，可以通过<code>kube-apiserver</code>启动参数进行配置。</p><a id="more"></a><p class="note note-primary">以下分析仅基于 Kubernetes:1.13 </p><p>从来源而言，可分为静态钩子和动态钩子，前者指的是<code>kubernetes</code>提供的原生能力，代码直接编译在<code>kube-apiserver</code>二进制中，后者即两个<code>webhook</code>。从功能而言，可分为<code>validating</code>和<code>mutating</code>，前者只做校验，后者会修改或补充资源中的信息。</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p><strong>Admission Controller</strong> 的开关分为以下三部分</p><h2 id="default"><a href="#default" class="headerlink" title="default"></a>default</h2><p>无需任何配置，默认打开</p><pre><code class="hljs bash">kube-apiserver -h | grep <span class="hljs-built_in">enable</span>-admission-plugin&gt;&gt; admission plugins that should be enabled <span class="hljs-keyword">in</span> addition to default enabled ones (NamespaceLifecycle, LimitRanger, ServiceAccount, TaintNodesByCondition, Priority, DefaultTolerationSeconds, DefaultStorageClass, PersistentVolumeClaimResize, MutatingAdmissionWebhook, ValidatingAdmissionWebhook, ResourceQuota). Comma-delimited list of admission plugins: AlwaysAdmit, AlwaysDeny, AlwaysPullImages, DefaultStorageClass, DefaultTolerationSeconds, DenyEscalatingExec, DenyExecOnPrivileged, EnableIpv6, EventRateLimit, ExtendedResourceToleration, ImagePolicyWebhook, IngressAnnotations, Initializers, LimitPodHardAntiAffinityTopology, LimitRanger, MutatingAdmissionWebhook, NamespaceAutoProvision, NamespaceExists, NamespaceLifecycle, NodeRestriction, OwnerReferencesPermissionEnforcement, PersistentVolumeAnnotations, PersistentVolumeClaimResize, PersistentVolumeLabel, PodNodeSelector, PodPreset, PodSecurityPolicy, PodTolerationRestriction, Priority, ResourceQuota, SecurityContextDeny, ServiceAccount, ServiceAnnotations, StorageObjectInUseProtection, TaintNodesByCondition, ValidatingAdmissionWebhook. The order of plugins <span class="hljs-keyword">in</span> this flag does not matter.</code></pre><h2 id="enable"><a href="#enable" class="headerlink" title="enable"></a>enable</h2><p>在 <strong>Admission Controller</strong> 列表中但不在default里，手动开启</p><pre><code class="hljs bash">kube-apiserver --<span class="hljs-built_in">enable</span>-admission-plugins=NamespaceLifecycle,LimitRanger</code></pre><h2 id="disable"><a href="#disable" class="headerlink" title="disable"></a>disable</h2><p>在 <strong>Admission Controller</strong> 列表中，但不需要，手动关闭</p><pre><code class="hljs undefined">kube-apiserver <span class="hljs-attribute">--disable-admission-plugins</span>=NamespaceLifecycle,LimitRanger</code></pre><p>以上两个配置，控制器的先后顺序没有区别</p><p>实际上的先后顺序是在编译时决定的，可参见以下文件内容</p><pre><code class="hljs go"><span class="hljs-comment">// k8s.io/kubernetes/pkg/kubeapiserver/options/plugins.go</span><span class="hljs-comment">// AllOrderedPlugins is the list of all the plugins in order.</span><span class="hljs-keyword">var</span> AllOrderedPlugins = []<span class="hljs-keyword">string</span>&#123;admit.PluginName,                        <span class="hljs-comment">// AlwaysAdmit</span>autoprovision.PluginName,                <span class="hljs-comment">// NamespaceAutoProvision</span>lifecycle.PluginName,                    <span class="hljs-comment">// NamespaceLifecycle</span>exists.PluginName,                       <span class="hljs-comment">// NamespaceExists</span>scdeny.PluginName,                       <span class="hljs-comment">// SecurityContextDeny</span>antiaffinity.PluginName,                 <span class="hljs-comment">// LimitPodHardAntiAffinityTopology</span>podpreset.PluginName,                    <span class="hljs-comment">// PodPreset</span>limitranger.PluginName,                  <span class="hljs-comment">// LimitRanger</span>serviceaccount.PluginName,               <span class="hljs-comment">// ServiceAccount</span>noderestriction.PluginName,              <span class="hljs-comment">// NodeRestriction</span>nodetaint.PluginName,                    <span class="hljs-comment">// TaintNodesByCondition</span>alwayspullimages.PluginName,             <span class="hljs-comment">// AlwaysPullImages</span>enableipv6.PluginName,                   <span class="hljs-comment">// EnableIpv6</span>imagepolicy.PluginName,                  <span class="hljs-comment">// ImagePolicyWebhook</span>podsecuritypolicy.PluginName,            <span class="hljs-comment">// PodSecurityPolicy</span>podnodeselector.PluginName,              <span class="hljs-comment">// PodNodeSelector</span>podpriority.PluginName,                  <span class="hljs-comment">// Priority</span>defaulttolerationseconds.PluginName,     <span class="hljs-comment">// DefaultTolerationSeconds</span>podtolerationrestriction.PluginName,     <span class="hljs-comment">// PodTolerationRestriction</span>exec.DenyEscalatingExec,                 <span class="hljs-comment">// DenyEscalatingExec</span>exec.DenyExecOnPrivileged,               <span class="hljs-comment">// DenyExecOnPrivileged</span>eventratelimit.PluginName,               <span class="hljs-comment">// EventRateLimit</span>extendedresourcetoleration.PluginName,   <span class="hljs-comment">// ExtendedResourceToleration</span>label.PluginName,                        <span class="hljs-comment">// PersistentVolumeLabel</span>setdefault.PluginName,                   <span class="hljs-comment">// DefaultStorageClass</span>storageobjectinuseprotection.PluginName, <span class="hljs-comment">// StorageObjectInUseProtection</span>gc.PluginName,                           <span class="hljs-comment">// OwnerReferencesPermissionEnforcement</span>resize.PluginName,                       <span class="hljs-comment">// PersistentVolumeClaimResize</span>mutatingwebhook.PluginName,              <span class="hljs-comment">// MutatingAdmissionWebhook</span>initialization.PluginName,               <span class="hljs-comment">// Initializers</span>validatingwebhook.PluginName,            <span class="hljs-comment">// ValidatingAdmissionWebhook</span>resourcequota.PluginName,                <span class="hljs-comment">// ResourceQuota</span>deny.PluginName,                         <span class="hljs-comment">// AlwaysDeny</span>annotation.PluginName,                   <span class="hljs-comment">// PersistentVolumeAnnotations</span>serviceannotation.PluginName,            <span class="hljs-comment">// ServiceAnnotations</span>ingressannotation.PluginName,            <span class="hljs-comment">// IngressAnnotations</span>&#125;</code></pre><h1 id="支持列表"><a href="#支持列表" class="headerlink" title="支持列表"></a>支持列表</h1><h2 id="废弃"><a href="#废弃" class="headerlink" title="废弃"></a>废弃</h2><p><strong>AlwaysAdmit</strong> [deprecated]</p><p>不检查，直接放行，等于没配。</p><p><strong>AlwaysDeny</strong> [deprecated]</p><p>直接拒绝，没有使用场景。</p><p><strong>DenyExecOnPrivileged</strong> [deprecated]</p><p>禁止了对特权容器的 <code>exec</code> 操作，功能雷同，建议使用 <strong>DenyEscalatingExec</strong> 。</p><p><strong>DenyEscalatingExec</strong> [deprecated]</p><p>禁止了对特权容器的<code>exec</code>和<code>attach</code>操作，否则可以借此绕过操作系统验证，获取节点上的极大操作权限。建议改用 <strong>PodSecurityPolicy</strong> 做更精准的限制。</p><p><strong>PersistentVolumeLabel</strong> [deprecated]</p><p>自动给<code>pv</code>和<code>pod</code>打<code>label</code>，防止其创建到不同<code>region</code>上去。</p><p>怎么看都觉得这种是各个云服务提供商应该操心的事，不应该在主线分支里提供这种东西，被废弃也理所当然吧。</p><h2 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h2><p><strong>TaintNodesByCondition</strong></p><p>依据<code>node.condition</code>给<code>node</code>自动打<code>taint</code>。</p><p><strong>DefaultTolerationSeconds</strong></p><p>为所有<code>pod</code>添加以下<code>toleration</code>，如果已有相同<code>key</code>值不会覆盖</p><pre><code class="hljs yaml"><span class="hljs-attr">tolerations:</span><span class="hljs-attr">- effect:</span> <span class="hljs-string">NoExecute</span><span class="hljs-attr">  key:</span> <span class="hljs-string">node.kubernetes.io/not-ready</span><span class="hljs-attr">  operator:</span> <span class="hljs-string">Exists</span><span class="hljs-attr">  tolerationSeconds:</span> <span class="hljs-number">300</span><span class="hljs-attr">- effect:</span> <span class="hljs-string">NoExecute</span><span class="hljs-attr">  key:</span> <span class="hljs-string">node.kubernetes.io/unreachable</span><span class="hljs-attr">  operator:</span> <span class="hljs-string">Exists</span><span class="hljs-attr">  tolerationSeconds:</span> <span class="hljs-number">300</span></code></pre><p>防止因为各种原因（网络/存储等），<code>kubelet</code>在<code>ready/notReady</code>间跳变，会瞬间将上面的<code>pod</code>全部驱逐。</p><p><strong>ExtendedResourceToleration</strong></p><p>为拥有扩展资源的节点(如<code>nvidia.com/GPU</code>)打上<code>taint</code>，并给申请该扩展资源的<code>pod</code>打<code>toleration</code>，防止拥有扩展资源的节点被其他普通请求的<code>pod</code>占满。</p><p><strong>PodTolerationRestriction</strong></p><p>检查<code>pod.toleration</code>和<code>namespace</code>是否有冲突，并合并命名空间的默认配置到<code>pod</code>上，命名空间的<code>toleration</code>的通过两个<code>annotation</code>(<code>scheduler.alpha.kubernetes.io/defaultTolerations</code> 和 <code>scheduler.alpha.kubernetes.io/tolerationsWhitelist</code> ) 进行标记。没有想到啥使用场景，可能用于对某些<code>namespace</code>自动打<code>toleration</code>？</p><p><strong>NamespaceAutoProvision</strong></p><p>自动创建资源中要求的但不存在的<code>namespace</code>。</p><p><strong>NamespaceExists</strong></p><p>强制校验资源中要求的<code>namespace</code>存在。</p><p><strong>NamespaceLifecycle</strong></p><p>保证删除<code>namespace</code>时不允许继续往其下面创建资源；不允许资源指定不存在的<code>namespace</code>；保证三个默认命名空间<code>default / kube-system / kub-plublic</code>存在，即禁止删除它们。</p><p><strong>EventRateLimit</strong> [alpha]</p><pre><code class="hljs bash">kube-apiserver --<span class="hljs-built_in">enable</span>-admission-plugins=EventRateLimit --admission-control-config-file=<span class="hljs-variable">$&#123;ADMISSION_CONTROL_CONFIG_FILE&#125;</span></code></pre><p>简单而言，通过以上配置来控制事件的速率，防止由于事件的请求过大压垮整个集群。当前允许的控制级别有</p><ul><li>集群</li><li>单个<code>namespace</code></li><li>单个用户</li><li>特定来源</li></ul><p>详见 <a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/admission_control_event_rate_limit.md" target="_blank" rel="noopener">Admission control plugin: EventRateLimit</a></p><h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><p><strong>LimitPodHardAntiAffinityTopology</strong></p><p>对于所有<code>pod</code>的<code>requiredDuringSchedulingRequiredDuringExecution</code>策略，只允许<code>kubernetes.io/hostname</code>此<code>key</code>值，不允许反亲和其他标签。没啥想法，可能利于防止反亲和的策略过复杂对调度效率产生影响。</p><p><strong>NodeRestriction</strong></p><p>在<code>--authorization-mode=Node</code>之上，继续缩小<code>system:node</code>的权限。主要为</p><ul><li>只允许修改此<code>system:node:&lt;node-name&gt;</code>管理的<code>node</code>及<code>pod</code>（但不限制读）</li><li><code>update</code>时禁止增加或修改<code>node</code>的<code>taint</code></li><li>除以下系统定义的<code>label</code>域外，禁止修改或增加这三个头域的标签 <code>.*node-restriction.kubernetes.io/</code>，<code>.*kubernetes.io/</code>，<code>.*k8s.io/</code><ul><li>值得注意的是，在<code>create</code>时，这个行为只会被<code>klog.Warning</code>后放行；但在<code>update</code>时，这个行为会被拒绝</li></ul></li></ul><pre><code class="hljs go"><span class="hljs-comment">// white list label</span><span class="hljs-comment">// plugin/pkg/admission/noderestriction/admission.go#L445-L464</span>kubernetes.io/hostnamefailure-domain.beta.kubernetes.io/zonefailure-domain.beta.kubernetes.io/regionbeta.kubernetes.io/instance-<span class="hljs-keyword">type</span>beta.kubernetes.io/osbeta.kubernetes.io/archfailure-domain.kubernetes.io/zonefailure-domain.kubernetes.io/regionkubernetes.io/instance-<span class="hljs-keyword">type</span>kubernetes.io/oskubernetes.io/archkubelet.kubernetes.io/.*node.kubernetes.io/.*</code></pre><p>详见 <a href="https://kubernetes.io/docs/reference/access-authn-authz/node/" target="_blank" rel="noopener">Using Node Authorization</a></p><p><strong>PodNodeSelector</strong></p><p>自动为<code>pod</code>补<code>nodeSelector</code>，拒绝不合法的<code>nodeSelector</code>。用于多租场景下，限制某个<code>namespace</code>下的资源只允许在某些<code>node</code>上，即节点的独立性，比如生产环境和测试环境隔离，或者价值高的节点限制普通用户的<code>pod</code>瞎调。</p><p>可参考 <a href="https://www.mgasch.com/post/podnodesel/" target="_blank" rel="noopener">Understanding and using the Kubernetes PodNodeSelector Admission Controller</a></p><p><strong>Priority</strong></p><p>检查<code>pod</code>创建时指定的<code>priorityClassName</code>存在。</p><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p><strong>DefaultStorageClass</strong></p><p>为<code>pvc</code>配置默认的<code>storageclass</code>类型。</p><p><strong>StorageObjectInUseProtection</strong></p><p>给<code>pv / pvc</code>增加<code>annotation</code>，在其删除时增加<code>finalize</code>。</p><p><strong>PersistentVolumeClaimResize</strong></p><p>需要打开这个<code>--feature-gates=ExpandPersistentVolumes=true</code>，若<code>PersistentVolumeClaim</code>的<code>StorageClass</code>不允许扩容(<code>allowVolumeExpansion: fasle</code>)，阻止相关操作。</p><h2 id="多租"><a href="#多租" class="headerlink" title="多租"></a>多租</h2><p><strong>AlwaysPullImages</strong></p><p>强行更新所有<code>pod.container</code>的<code>imagePullPolicy</code>为<code>Always</code>。适用于多租场景，防止租户通过镜像名使用节点上已有的其他租户镜像。</p><p><strong>ImagePolicyWebhook</strong></p><p>外注册类型的钩子，需要一个外部的<code>webhook</code>，任何<code>annotation</code>为<code>*.image-policy.k8s.io/*</code>的<code>pod</code>都会确认一遍这个镜像是否允许被使用。没有联想到什么使用场景。</p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p><strong>PodPreset</strong> [alpha]</p><p>与<code>PodPreset</code>配套使用，按照预置信息填充<code>pod</code>。<code>PodPreset</code>是<code>kubernetes</code>的一种资源，可视为一个模板，通过<code>label</code>与<code>pod</code>相关联，用于自动补全<code>pod</code>的相关信息。</p><p>详见 <a href="https://kubernetes.io/docs/tasks/inject-data-application/podpreset/" target="_blank" rel="noopener">Inject Information into Pods Using a PodPreset</a></p><h2 id="资源限制"><a href="#资源限制" class="headerlink" title="资源限制"></a>资源限制</h2><p><strong>LimitRanger</strong></p><p>与<code>LimitRange</code>配套使用，检查是否满足其资源限制。<code>LimitRange</code>是<code>kubernetes</code>中资源的一种，用于限制单个<code>Pod/Container/PersistentVolumeClaim</code>的资源请求，可用于以下场景</p><ul><li>配置默认的<code>limit</code>或<code>request</code></li><li>限制资源<code>limit</code>最大值</li><li>限制资源<code>limit</code>最小值</li><li>限制资源最大的 <code>limit/request</code> 比率</li></ul><p><strong>ResourceQuota</strong></p><p>与<code>resourceQuota</code>配套使用，检查要求资源未超过限制。</p><p>详见 <a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/resource-management/admission_control_resource_quota.md" target="_blank" rel="noopener">Admission control plugin: ResourceQuota</a></p><h2 id="权限限制"><a href="#权限限制" class="headerlink" title="权限限制"></a>权限限制</h2><p><strong>OwnerReferencesPermissionEnforcement</strong></p><p>修改<code>metadata.ownerReferences</code>需要<code>delete</code>权限。</p><p><strong>PodSecurityPolicy</strong></p><p>与<code>PodSecurityPolicies</code>配套使用，对<code>pod</code>策略进行校验。<code>PodSecurityPolicies</code>是<code>kubernetes</code>的一种资源，用于限制容器中的特殊权限，必须关联到<code>Role/ClusterRole</code>上，并绑定到对应用户才能发挥功能。</p><pre><code class="hljs yaml"><span class="hljs-attr">rules:</span><span class="hljs-attr">- apiGroups:</span> <span class="hljs-string">['policy']</span><span class="hljs-attr">  resources:</span> <span class="hljs-string">['podsecuritypolicies']</span><span class="hljs-attr">  verbs:</span>     <span class="hljs-string">['use']</span></code></pre><p>详见 <a href="https://kubernetes.io/docs/concepts/policy/pod-security-policy/" target="_blank" rel="noopener">Pod Security Policies</a></p><p><strong>SecurityContextDeny</strong></p><p>拒绝任何<code>pod</code>的提权操作（指获取更高的权限），社区的建议是如果集群没有通过<code>PodSecurityPolicy</code>进行权限管理则应该开启。</p><p><strong>ServiceAccount</strong></p><p>根据<code>ServiceAccountName</code>补全相关信息</p><h2 id="动态"><a href="#动态" class="headerlink" title="动态"></a>动态</h2><p><strong>MutatingAdmissionWebhook</strong></p><p>串行调用，允许修改内容</p><p><strong>ValidatingAdmissionWebhook</strong></p><p>并行调用，不允许修改其内容</p><h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p><a href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/" target="_blank" rel="noopener">kubernetes-Using Admission Controllers</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
